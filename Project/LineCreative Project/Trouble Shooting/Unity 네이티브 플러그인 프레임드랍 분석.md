
### ## 1. 개요

Unity 에디터에서 `AVProMovieCapture` 플러그인을 사용한 영상 녹화 중, 간헐적으로 5초 이상 멈추는 심각한 프레임 드랍 현상이 발생. 초기에는 GPU 문제로 추정했으나, 다양한 분석 도구를 통해 원인이 **네이티브 DLL 내부의 동기화 문제**로 밝혀짐. 오디오 데이터 처리가 렌더 파이프라인과 동기적으로 얽혀, 에디터 부하 시 **메인 스레드와 렌더 스레드가 서로를 기다리는 교착 상태(Deadlock)**에 빠지는 것이 원인이었음. 해결책으로 오디오 처리 로직을 별도의 스레드로 분리하는 **생산자-소비자 패턴**을 적용하기로 함.

---

### ## 2. 최초 증상

- Unity 에디터 Play 모드에서 영상 캡처 시, 특정 상황에서 화면이 5초 이상 완전히 멈추는 현상 발생.
    
- 에디터 환경에서 확인
    

---

### ## 3. 트러블슈팅 과정 (3일)

#### **가설 1 - GPU 병목 현상**

- **사용한 도구**: `RenderDoc`, `Visual Studio 성능 프로파일러 (GPU 사용량)`
    
- **분석 과정**:
    
    1. 프레임 드랍 현상은 렌더링 부하 문제일 것이라는 가설로 접근.
        
    2. `RenderDoc`으로 문제의 프레임을 캡처하여 분석했으나, 드로우콜 수나 셰이더 복잡도, 텍스처 리소스 등에서 특별한 병목 지점을 찾지 못함.
        
    3. `VS 성능 프로파일러`의 GPU 사용량 뷰를 통해 실시간 GPU 점유율을 확인했으나, 프레임이 멈추는 동안 GPU는 거의 유휴상태임을 확인.
        
- **결론**: **GPU는 원인이 아님.** 문제는 CPU 단에 있을 것으로 추정하고 방향을 전환.
    

#### **가설 2 - CPU 메인 스레드 블로킹**

- **사용한 도구**: `Visual Studio 성능 프로파일러 (CPU 사용량)`, `Ghidra`
    
- **분석 과정**:
    
    1. `VS 성능 프로파일러`의 CPU 사용량 툴로 전환하여 프로파일링.
        
    2. 분석 결과, 3초의 시간 동안 **`[외부 코드]([External Code])`** 항목이 CPU를 100% 점유하고 있음을 발견. 이를 통해 **네이티브 DLL(`AVProMovieCapture.dll`)** 호출이 원인임을 특정함.
        
    3. 프로파일러가 DLL 내부 함수 이름을 보여주지 못하는 한계가 있어`Ghidra`를 사용해 DLL 내부 구조를 리버스 엔지니어링함.
        
    4. `GetRenderEventFunc`와 `GL.IssuePluginEvent`를 통해 C#과 DLL이 통신하는 저수준 호출 방식을 파악함. DLL 내부에 '이벤트 처리 허브 함수'가 존재하며, 이벤트 ID에 따라 `EncodeFrame`, `EncodeAudio` 등의 실제 작업을 분기 처리하는 구조임을 확인함.
        
- **결론**: **`AVProMovieCapture.dll` 호출이 메인 스레드를 블로킹**하는 것은 확실하나, 정확히 '왜' 블로킹하는지에 대한 근본적인 구조 파악이 필요해짐.
    

#### **원인 특정 및 구조 분석**

- **사용한 도구**: `Process Monitor`, 종합 분석
    
- **분석 과정**:
    
    1. 혹시 모를 파일 I/O나 시스템 락 문제를 확인하기 위해 `Process Monitor`를 사용했으나, 특별한 외부 I/O 병목은 발견되지 않음. 문제를 순수하게 스레드 동기화 문제로 좁힘.
        
    2. 지금까지의 모든 단서(GPU 유휴, CPU 블로킹, `GL.IssuePluginEvent` 구조, 오디오/비디오 동시 인코딩)를 종합하여 **'오디오-비디오 싱크 대기로 인한 교착 상태'**라는 최종 가설을 수립함.
    

---

### ## 4. 근본 원인

에디터 부하 등으로 인해 메인 스레드에서 동기적으로 처리되던 오디오 데이터의 준비가 늦어질 경우, 렌더 스레드에서 실행되는 비디오 인코딩 파트가 해당 오디오 데이터를 기다리며 대기 상태에 빠짐. 이는 해당 플러그인의 타임스탬프 인코딩 방식이 원인인걸로 보임 이로 인해 렌더 파이프라인 전체가 멈추고, 결국 다음 프레임으로 넘어가기 위해 렌더 스레드와 동기화되어야 하는 메인 스레드까지 블로킹되는 **'스레드 교착 상태'**가 문제의 핵심.

---

### ## 5. 해결책

오디오 데이터 수집(생산자)과 인코딩(소비자)을 분리하는 **생산자-소비자 패턴**의 함수 바운더리를 명확히 분리함

1. OnAudioFilterRead가 오디오 스레드에서 데이터를 버퍼에 메인스레드와 상관없이 채워넣으면
2. 캡쳐를 진행할때 동기적으로 오디오버퍼에서 빼는게 아니라 (이는 소비자 측에 들어가야함) 비동기로 네이티브 플러그인을 호출해야함
