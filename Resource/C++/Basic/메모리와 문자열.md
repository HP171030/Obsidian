
## 1. C++ 변수와 메모리 할당

* **기본 원칙:** C++에서 변수를 선언하면 컴파일러와 운영체제 메모리 관리자가 해당 변수에 메모리 공간을 할당한다.

* **메모리 영역:**
    * **스택 (Stack):** 함수 내 지역 변수들이 할당되는 영역. 함수 호출 시 생성되고, 함수 종료 시 자동으로 해제된다. 빠르지만 크기 제한이 있고, 함수 종료 시 데이터가 '반납'될 뿐 '청소'되지는 않는다.
    * **힙 (Heap):** `new`, `malloc` 등을 사용하여 프로그래머가 직접 동적으로 할당하고 해제하는 영역. 크기 제한이 적지만, 수동 관리가 필요하며, 관리 오류 시 메모리 누수 발생 가능.
    * **정적 메모리 (Static/Global/Data Segment):** 프로그램 시작 시 할당되어 종료 시까지 유지되는 영역. 전역 변수, 정적 변수, 그리고 **문자열 리터럴**이 저장된다. 주로 읽기 전용(read-only) 영역이 있다.

* **메모리 주소 직접 제어:** 일반적인 C++ 코드에서 특정 물리적/가상 메모리 주소에 변수를 강제로 위치시키는 것은 **거의 불가능하며 매우 위험하다.** (임베디드/커널 프로그래밍 같은 특수 상황 제외)

* **포인터의 역할:**
    * 메모리 주소를 저장하는 변수.
    * `new`나 `malloc`으로 동적 할당된 메모리의 시작 주소를 가리키거나, 기존 변수의 주소를 받아 간접적으로 접근할 때 사용한다.
    * **"내가 원하는 특정 숫자 주소에 데이터를 할당"하는 용도가 아님.** 대부분 접근 위반 오류(Access Violation)를 발생시킨다.

## 2. 문자열 리터럴 (`""`)

* **정의:** 큰따옴표 `""`로 묶인 문자열 (예: `"Hello World"`).
* **특징:**
    * **상수성 (Constant):** 한 번 정의되면 프로그램 실행 중에 그 내용을 **변경할 수 없다.** 변경 시도 시 **미정의 동작(Undefined Behavior, UB)** 발생 (프로그램 충돌 가능성 높음).
    * **정적 메모리 저장:** 컴파일 시점에 **정적 메모리(주로 읽기 전용 영역)**에 저장된다. 프로그램 시작 시 로드되어 종료 시까지 존재한다.
    * **모든 문자열 리터럴은 그 자체로 정적 메모리에 저장된다.**

* **`char*` vs `const char*`:**
    * **`const char* str = "Hello";
        * 문자열 리터럴의 불변성(Immutable Nature)을 명시적으로 반영한다.
        * 포인터가 가리키는 내용을 변경하려 할 때 **컴파일 시점에 에러를 발생시켜 오류를 예방**한다. 
    * **`char* str = "Hello";` 
        * C++98/03 시절에는 허용되었지만, **상수성 위반의 잠재적 위험** 때문에 최신 C++에서는 사용하지 않는다.
        * `str[0] = 'J';` 처럼 내용을 변경하려고 시도하면 **런타임에 미정의 동작(UB)이 발생**하여 프로그램이 충돌할 수 있다.

* **`char[]`로 초기화 시:**
    ```cpp
    char localArr[] = "Hello";
    ```
    * 문자열 리터럴 `"Hello"` 자체는 여전히 **정적 메모리**에 저장된다.
    * `localArr` 배열 자체는 함수 호출 시 **스택 메모리**에 할당된다.
    * 컴파일 시 또는 런타임 초기화 시, **정적 메모리의 `"Hello"` 내용이 `localArr` (스택)으로 복사된다.**
    * `localArr`은 스택에 있는 **복사본**이므로, 그 내용을 자유롭게 변경할 수 있다.

## 3. `std::string` (가변 문자열)

* **필요성:** 프로그램 실행 중 내용이 변경되거나 크기가 달라질 수 있는 **가변 문자열**이 필요할 때 사용한다.
* **특징:**
    * **가변성 (Mutable):** 문자 추가, 삭제, 삽입, 대입 등 내용을 자유롭게 변경할 수 있다.
    * **동적 메모리 관리:** 문자열 길이에 따라 필요한 메모리를 **힙(Heap)**에 동적으로 할당하고 관리한다. 개발자가 직접 `new/delete`를 호출할 필요가 없어 편리하고 안전하다.
    * **풍부한 기능:** 문자열 조작을 위한 다양한 멤버 함수(길이, 검색, 부분 문자열, 결합 등)와 연산자 오버로딩을 제공한다.
    * **안전성:** C스타일 문자열에 비해 버퍼 오버플로우 등 잠재적 오류를 줄여준다.

## 4. 컴파일러 최적화: 문자열 풀링 (String Pooling / Interning)

* **목표:** 코드 내에 동일한 내용의 문자열 리터럴이 여러 번 나올 때, 메모리 사용량을 줄이고 캐시 효율성을 높여 성능을 최적화하는 기법.
* **작동 방식 (일반적 컴파일러):**
    * 컴파일러는 내부적으로 **해시 테이블(Hash Table)**을 사용하여 이전에 처리한 문자열 리터럴들을 관리한다.
    * 새로운 문자열 리터럴을 발견하면, 그 내용을 기반으로 **해시 값**을 계산한다.
    * 계산된 해시 값을 사용하여 해시 테이블에서 동일한 문자열이 이미 있는지 **$O(1)$의 평균 시간 복잡도로 빠르게 확인**한다.
    * **이미 존재하면:** 기존에 정적 메모리에 저장된 해당 문자열의 주소를 재사용한다.
    * **존재하지 않으면:** 새로운 문자열을 정적 메모리에 할당하고 테이블에 추가한다.
* **MSVC의 문자열 풀링 (`/GF` 옵션):**
    * MSVC는 문자열 리터럴의 내용을 기반으로 **고유한 '이름표'(맹글링된 이름)**를 만들고, 이를 **COMDAT 섹션**이라는 특별한 영역에 배치한다.
    * **링커(Linker)**가 여러 컴파일된 오브젝트 파일들을 최종 실행 파일로 합칠 때, 이 '이름표'를 보고 **동일한 이름표를 가진 문자열 리터럴은 단 한 개만 포함시키고 나머지는 버린다.**
    * 이 방식은 **단일 `.cpp` 파일뿐만 아니라 여러 `.cpp` 파일에 걸쳐서도 문자열 중복 제거를 가능하게 한다.**

**결론:** C++에서 문자열을 다룰 때는 불변성과 가변성의 필요에 따라 `const char*` (리터럴) 또는 `std::string`을 적절히 선택하여 사용하며, 컴파일러는 이러한 문자열 리터럴을 효율적으로 관리하기 위해 강력한 최적화(문자열 풀링)를 수행한다.