## 1. new 연산자
어떤 데이터형을 원하는지 new 연산자에게 알려주면
new 연산자는 그에 맞는 크기의 메모리블록을 찾아내고 그 블록의 주소를 리턴함
```cpp
int* _int = new int;
```

## 2. delete 연산자
사용한 메모리를 다시 메모리풀로 환수
환수된 메모리는 프로그램의 다른 부분이 다시 사용

```cpp
delete _int;_
```

---

1. new로 대입하지 않은 메모리는 delete로 해제할 수 없다
2. 같은 메모리 블록을 연달아 두 번 delete로 해제할 수 없다
3. new[]로 메모리를 대입할 경우 delete[]로 해제한다
4. 대괄호를 사용하지 않았다면 delete도 사용하지 않는다


---
```cpp
#include <iostream> 
using namespace std; 

int main()
{
	//double 크기 만큼 3개의 공간 할당하여 배열로 사용
	double* p3 = new double[3]; 
	
	p3[0] = 0.2; 
	p3[1] = 0.5; 
	p3[2] = 0.8; 
	
	cout << "p3[1] is " << p3[1] << ".\n"; 
// p3의 포인팅을 메모리 공간에서 한칸만큼 뒤로 간 만큼을 포인팅하도록 재설정
	p3 = p3 + 1; 
	cout << "Now p3[0] is " << p3[0] << " and "; 
	cout << "p3[1] is " << p3[1] << "\n."; 
	p3 = p3-1; 
	delete[] p3; 
	return 0; 
	}
```

배열 자체에는 당연히 연산을 시행할 수 없지만
포인터변수는 변수처럼 사용할 수 있다.


정리하면 new 는 그 크기만큼을 메모리에 할당한다고 선언하고 시작주소를 반환하는거고

delete는 그 크기만큼을 메모리에서 반환함 (즉 시작주소를 알려줘야 정확히 동작함)


- cpp에서 디폴트생성자를 제공하지만 매개변수가 있는 사용자정의 생성자를 만들 경우 디폴트생성자는 사라짐
- 클래스 소멸자의 경우 생명주기가 끝나는 시점에 호출됨
- 동적할당된 클래스의 경우 (힙) 딜리트로 소멸을 명시해서 메모리를 해제해줘야함