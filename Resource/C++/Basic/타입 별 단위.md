
# 1. 기본 단위

- **1 바이트 (Byte) = 8 비트 (Bit)**
    - **비트(Bit)**: 0 또는 1, 가장 작은 정보 단위.
    - **바이트(Byte)**: 8비트의 묶음, 의미 있는 정보 단위.


| short | int | long | long long | bool |     |
| :---: | :-: | :--: | :-------: | ---- | --- |
|  16   | 32  |  32  |    64     | 8    |     |
|       |     |      |           |      |     |

---

# 2. C++ `long` 크기

- **가변적**: 컴파일러와 시스템 아키텍처(32비트/64비트)에 따라 다름.
    - **Windows (MSVC)**: 주로 **4바이트 (32비트)**
        - 64비트 Windows에서도 `long`은 4바이트 유지 (LLP64 데이터 모델).
    - **Linux/macOS (GCC/Clang)**: 64비트 시스템에서 **8바이트 (64비트)**
        - `long`과 포인터가 64비트 (LP64 데이터 모델).
- **참고**: 명확한 크기를 원하면 `long long` (항상 8바이트) 또는 `<cstdint>`의 `int32_t`, `int64_t` 사용 권장.

---

### 3. C# `long` 크기

- **고정적**: 항상 **8바이트 (64비트)**.
    - 플랫폼(Windows/Linux)이나 비트(32비트/64비트)에 상관없이 동일.
    - `System.Int64` 형식.

---

### 4. `long`이 존재하는 이유

- **역사적 이유 및 이식성**:
    - 과거 16비트 시스템에서 `int`가 2바이트일 때, 4바이트 정수를 위해 `long`이 도입됨.
    - `int`보다 '최소한 같거나 더 큰' 범위를 보장하며 플랫폼 이식성을 도움.
- **개발자의 의도 표현**:
    - `int`보다 큰 값이 올 수 있음을 암시하여 코드 가독성 향상.

---

# char(작은 문자형)

ASCII 코드로 표현할 수 있는 문자체계에서 한 단어를 표현한다

```cpp
int a = 77;
char b = a;
```
- 이 경우에서 b를 std::cout 으로 출력할 경우
- 암시적 변환이 일어나 int값이 char에 할당될 때 ASCII 코드로 77을 표현하면 'M'으로 출력된다
- 근본적으로는 정수형으로 저장된다


```cpp
char b[] = {'a','b','c','\0'};
```

- std::cout 으로 출력 할 경우
- null 문자 \0으로 char 배열이 끝났다는걸 알릴 수 있다.
- string에는 안에는 null 문자가 포함되어있다.
- null 문자를 명시해주지 않는다면 우연히 널문자를 만날때까지 메모리를 계속 돈다.

---
# bool

0과 1로 참, 거짓을 표현하는 타입
```cpp
bool a = 1;
bool b = 0;
bool c = 10;
```
- 이 경우 std::cout으로 출력하면 a = 1, b = 0, c = 1로 0 이 아닌 모든 값을 1로 저장해서 나타낸다

---
# auto

초기화 시 cpp에게 데이터 타입을 결정하도록 하게 하는것

```cpp
auto n = 100;   int
auto x = 1.5;   float
auto y = 1.3e12L    long long
```
